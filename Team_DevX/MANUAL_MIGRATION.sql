DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'problem_status') THEN
        CREATE TYPE problem_status AS ENUM ('reported', 'under_review', 'approved', 'in_progress', 'completed', 'rejected');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'problem_category') THEN
        CREATE TYPE problem_category AS ENUM ('roads', 'water', 'electricity', 'sanitation', 'education', 'healthcare', 'pollution', 'safety', 'other');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role') THEN
        CREATE TYPE user_role AS ENUM ('citizen', 'ministry', 'admin');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vote_type') THEN
        CREATE TYPE vote_type AS ENUM ('upvote', 'downvote');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'votable_type') THEN
        CREATE TYPE votable_type AS ENUM ('problem', 'solution');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'commentable_type') THEN
        CREATE TYPE commentable_type AS ENUM ('problem', 'solution');
    END IF;
END
$$;

-- Create profiles table
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name TEXT NOT NULL,
  points INTEGER DEFAULT 0,
  badges TEXT[] DEFAULT '{}',
  role user_role DEFAULT 'citizen',
  latitude DECIMAL(10, 8),
  longitude DECIMAL(11, 8),
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Create problems table
CREATE TABLE IF NOT EXISTS public.problems (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  category problem_category NOT NULL,
  media_url TEXT,
  latitude DECIMAL(10, 8) NOT NULL,
  longitude DECIMAL(11, 8) NOT NULL,
  status problem_status DEFAULT 'reported',
  votes_count INTEGER DEFAULT 0,
  ai_tags TEXT[] DEFAULT '{}',
  ai_summary TEXT,
  is_flagged BOOLEAN DEFAULT FALSE,
  is_deleted BOOLEAN DEFAULT FALSE,
  quality_score FLOAT,
  moderation_reason TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Create solutions table
CREATE TABLE IF NOT EXISTS public.solutions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  problem_id UUID REFERENCES public.problems(id) ON DELETE CASCADE NOT NULL,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  description TEXT NOT NULL,
  media_url TEXT,
  votes_count INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Create votes table
CREATE TABLE IF NOT EXISTS public.votes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  votable_type votable_type NOT NULL,
  votable_id UUID NOT NULL,
  vote_type vote_type NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(user_id, votable_type, votable_id)
);

-- Create comments table
CREATE TABLE IF NOT EXISTS public.comments (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  problem_id UUID REFERENCES public.problems(id) ON DELETE CASCADE,
  solution_id UUID REFERENCES public.solutions(id) ON DELETE CASCADE,
  parent_id BIGINT REFERENCES public.comments(id) ON DELETE CASCADE,
  content TEXT NOT NULL CHECK (length(content) > 0),
  is_deleted BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  sentiment TEXT,
  -- Ensure a comment is linked to either a problem or a solution, but not both or neither.
  CONSTRAINT chk_comment_parent
    CHECK (
      (problem_id IS NOT NULL AND solution_id IS NULL) OR
      (problem_id IS NULL AND solution_id IS NOT NULL)
    )
);

-- Enable RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.problems ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.solutions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.votes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.comments ENABLE ROW LEVEL SECURITY;

-- RLS Policies for profiles
DROP POLICY IF EXISTS "Users can view all profiles" ON public.profiles;
CREATE POLICY "Users can view all profiles"
  ON public.profiles FOR SELECT
  TO authenticated
  USING (true);

DROP POLICY IF EXISTS "Users can update their own profile" ON public.profiles;
CREATE POLICY "Users can update their own profile"
  ON public.profiles FOR UPDATE
  TO authenticated
  USING (auth.uid() = id);

DROP POLICY IF EXISTS "Users can insert their own profile" ON public.profiles;
CREATE POLICY "Users can insert their own profile"
  ON public.profiles FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = id);

-- RLS Policies for problems
DROP POLICY IF EXISTS "Anyone can view problems" ON public.problems;
CREATE POLICY "Anyone can view problems"
  ON public.problems FOR SELECT
  TO authenticated
  USING (true);

DROP POLICY IF EXISTS "Authenticated users can create problems" ON public.problems;
CREATE POLICY "Authenticated users can create problems"
  ON public.problems FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can update their own problems" ON public.problems;
CREATE POLICY "Users can update their own problems"
  ON public.problems FOR UPDATE
  TO authenticated
  USING (auth.uid() = user_id);

-- RLS Policies for solutions
DROP POLICY IF EXISTS "Anyone can view solutions" ON public.solutions;
CREATE POLICY "Anyone can view solutions"
  ON public.solutions FOR SELECT
  TO authenticated
  USING (true);

DROP POLICY IF EXISTS "Authenticated users can create solutions" ON public.solutions;
CREATE POLICY "Authenticated users can create solutions"
  ON public.solutions FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can update their own solutions" ON public.solutions;
CREATE POLICY "Users can update their own solutions"
  ON public.solutions FOR UPDATE
  TO authenticated
  USING (auth.uid() = user_id);

-- RLS Policies for votes
DROP POLICY IF EXISTS "Anyone can view votes" ON public.votes;
CREATE POLICY "Anyone can view votes"
  ON public.votes FOR SELECT
  TO authenticated
  USING (true);

DROP POLICY IF EXISTS "Authenticated users can create votes" ON public.votes;
CREATE POLICY "Authenticated users can create votes"
  ON public.votes FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can delete their own votes" ON public.votes;
CREATE POLICY "Users can delete their own votes"
  ON public.votes FOR DELETE
  TO authenticated
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can update their own votes" ON public.votes;
CREATE POLICY "Users can update their own votes"
  ON public.votes FOR UPDATE
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- RLS Policies for comments
DROP POLICY IF EXISTS "Anyone can view comments" ON public.comments;
CREATE POLICY "Anyone can view comments"
  ON public.comments FOR SELECT
  TO authenticated
  USING (true);

DROP POLICY IF EXISTS "Authenticated users can create comments" ON public.comments;
CREATE POLICY "Authenticated users can create comments"
  ON public.comments FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can update their own comments" ON public.comments;
CREATE POLICY "Users can update their own comments"
  ON public.comments FOR UPDATE
  TO authenticated
  USING (auth.uid() = user_id);

-- Create function to handle new user creation
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name)
  VALUES (new.id, COALESCE(new.raw_user_meta_data->>'full_name', 'Anonymous User'));
  RETURN new;
END;
$$;

-- Trigger for new user creation
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update timestamps
CREATE OR REPLACE FUNCTION public.update_updated_at()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

-- Triggers for updating timestamps
DROP TRIGGER IF EXISTS update_profiles_updated_at ON public.profiles;
CREATE TRIGGER update_profiles_updated_at
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

DROP TRIGGER IF EXISTS update_problems_updated_at ON public.problems;
CREATE TRIGGER update_problems_updated_at
  BEFORE UPDATE ON public.problems
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

DROP TRIGGER IF EXISTS update_solutions_updated_at ON public.solutions;
CREATE TRIGGER update_solutions_updated_at
  BEFORE UPDATE ON public.solutions
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_problems_user_id ON public.problems(user_id);
CREATE INDEX IF NOT EXISTS idx_problems_status ON public.problems(status);
CREATE INDEX IF NOT EXISTS idx_problems_category ON public.problems(category);
CREATE INDEX IF NOT EXISTS idx_problems_location ON public.problems(latitude, longitude);
CREATE INDEX IF NOT EXISTS idx_solutions_problem_id ON public.solutions(problem_id);
CREATE INDEX IF NOT EXISTS idx_votes_votable ON public.votes(votable_type, votable_id);

-- MIGRATION FILE SEPARATOR --
-- Fix search_path for update_updated_at function
CREATE OR REPLACE FUNCTION public.update_updated_at()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

-- MIGRATION FILE SEPARATOR --
create or replace function get_ministry_dashboard_stats()
returns json as $$
declare
  stats json;
begin
  select json_build_object(
    'total_problems', (select count(*) from problems),
    'problems_by_status', (select json_agg(t) from (select status, count(*) as count from problems group by status) t),
    'problems_by_category', (select json_agg(t) from (select category, count(*) as count from problems group by category) t),
    'top_category', (select category from problems group by category order by count(*) desc limit 1)
  ) into stats;
  
  return stats;
end;
$$ language plpgsql;


-- MIGRATION FILE SEPARATOR --
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id uuid not null default gen_random_uuid (),
    created_at timestamp with time zone not null default now(),
    user_id uuid null,
    action character varying not null,
    target_type character varying null,
    target_id character varying null,
    details jsonb null,
    constraint audit_logs_pkey primary key (id),
    constraint audit_logs_user_id_fkey foreign key (user_id) references profiles (id) on delete set null
);

-- Enable RLS
alter table public.audit_logs enable row level security;

-- Create policies
DROP POLICY IF EXISTS "Allow ministry and admin to read audit logs" ON public.audit_logs;
create policy "Allow ministry and admin to read audit logs" on public.audit_logs
as permissive for select
to authenticated
using (get_user_role(auth.uid()) in ('ministry', 'admin'));


-- MIGRATION FILE SEPARATOR --
create or replace function public.get_user_role(p_user_id uuid)
returns text
language sql
security definer
stable
as $$
  select role from public.profiles where id = p_user_id;
$$;


-- MIGRATION FILE SEPARATOR --
ALTER POLICY "Authenticated users can create problems" ON public.problems
WITH CHECK (auth.uid() = user_id);


-- MIGRATION FILE SEPARATOR --
CREATE OR REPLACE FUNCTION nearby_problems(lat float, long float)
RETURNS TABLE (
  id bigint,
  created_at timestamptz,
  title text,
  description text,
  category text,
  status text,
  upvotes_count integer,
  latitude float,
  longitude float,
  media_url text,
  user_id uuid,
  distance float
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    p.id,
    p.created_at,
    p.title,
    p.description,
    p.category,
    p.status,
    p.upvotes_count,
    p.latitude,
    p.longitude,
    p.media_url,
    p.user_id,
    (
      6371 * acos(
        cos(radians(lat)) * cos(radians(p.latitude)) *
        cos(radians(p.longitude) - radians(long)) +
        sin(radians(lat)) * sin(radians(p.latitude))
      )
    ) AS distance
  FROM
    public.problems p
  ORDER BY
    distance
  LIMIT 20;
END;
$$ LANGUAGE plpgsql;


-- MIGRATION FILE SEPARATOR --
-- ...existing code...


-- MIGRATION FILE SEPARATOR --
-- First, drop the existing trigger and function
DROP TRIGGER IF EXISTS on_vote_change ON public.votes;
DROP FUNCTION IF EXISTS public.update_votes_count();

-- Then, re-create the function with the corrected, unambiguous query
CREATE OR REPLACE FUNCTION public.update_votes_count()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  IF (TG_OP = 'INSERT') THEN
    IF (NEW.votable_type = 'problem') THEN
      UPDATE public.problems
      SET votes_count = votes_count + (CASE WHEN NEW.vote_type = 'upvote' THEN 1 ELSE -1 END)
      WHERE id = NEW.votable_id;
    ELSIF (NEW.votable_type = 'solution') THEN
      UPDATE public.solutions
      SET votes_count = votes_count + (CASE WHEN NEW.vote_type = 'upvote' THEN 1 ELSE -1 END)
      WHERE id = NEW.votable_id;
    END IF;
  ELSIF (TG_OP = 'DELETE') THEN
    IF (OLD.votable_type = 'problem') THEN
      UPDATE public.problems
      SET votes_count = votes_count - (CASE WHEN OLD.vote_type = 'upvote' THEN 1 ELSE -1 END)
      WHERE id = OLD.votable_id;
    ELSIF (OLD.votable_type = 'solution') THEN
      UPDATE public.solutions
      SET votes_count = votes_count - (CASE WHEN OLD.vote_type = 'upvote' THEN 1 ELSE -1 END)
      WHERE id = OLD.votable_id;
    END IF;
  END IF;
  RETURN NULL;
END;
$$;

-- Finally, re-create the trigger
DROP TRIGGER IF EXISTS on_vote_change ON public.votes;
CREATE TRIGGER on_vote_change
  AFTER INSERT OR DELETE ON public.votes
  FOR EACH ROW EXECUTE FUNCTION public.update_votes_count();


-- MIGRATION FILE SEPARATOR --
-- Create the comments table if it doesn't exist
CREATE TABLE IF NOT EXISTS public.comments (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  problem_id UUID REFERENCES public.problems(id) ON DELETE CASCADE,
  solution_id UUID REFERENCES public.solutions(id) ON DELETE CASCADE,
  parent_id BIGINT REFERENCES public.comments(id) ON DELETE CASCADE,
  content TEXT NOT NULL CHECK (length(content) > 0),
  is_deleted BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL,

  -- Ensure a comment is linked to either a problem or a solution, but not both or neither.
  CONSTRAINT chk_comment_parent
    CHECK (
      (problem_id IS NOT NULL AND solution_id IS NULL) OR
      (problem_id IS NULL AND solution_id IS NOT NULL)
    )
);

-- Add indexes for performance, checking if they exist first
CREATE INDEX IF NOT EXISTS idx_comments_user_id ON public.comments(user_id);
CREATE INDEX IF NOT EXISTS idx_comments_problem_id ON public.comments(problem_id);
CREATE INDEX IF NOT EXISTS idx_comments_solution_id ON public.comments(solution_id);
CREATE INDEX IF NOT EXISTS idx_comments_parent_id ON public.comments(parent_id);

-- Enable RLS (this is idempotent, so it's safe to run again)
ALTER TABLE public.comments ENABLE ROW LEVEL SECURITY;

-- Drop the trigger if it exists, then re-create it to ensure it's up to date
DROP TRIGGER IF EXISTS update_comments_updated_at ON public.comments;
CREATE TRIGGER update_comments_updated_at
  BEFORE UPDATE ON public.comments
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


-- MIGRATION FILE SEPARATOR --
-- First, drop all policies that depend on the function to avoid dependency errors.
DROP POLICY IF EXISTS "Allow authenticated users to view comments" ON public.comments;
DROP POLICY IF EXISTS "Allow citizens to create comments" ON public.comments;
DROP POLICY IF EXISTS "Allow citizens to update their own comments within a time limit" ON public.comments;
DROP POLICY IF EXISTS "Allow citizens to soft delete their own comments" ON public.comments;

-- Now, it is safe to drop and re-create the function.
-- ...existing code...
CREATE OR REPLACE FUNCTION get_my_role()
RETURNS TEXT AS $$
DECLARE
  user_role TEXT;
BEGIN
  SELECT role INTO user_role FROM public.profiles WHERE id = auth.uid();
  RETURN user_role;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Finally, re-create all the policies from a clean slate.

-- 1. Policy: Allow any authenticated user to view comments
CREATE POLICY "Allow authenticated users to view comments"
ON public.comments
FOR SELECT
TO authenticated
USING (is_deleted = false);

-- 2. Policy: Allow citizens to create comments
CREATE POLICY "Allow citizens to create comments"
ON public.comments
FOR INSERT
TO authenticated
WITH CHECK (
  get_my_role() = 'citizen' AND
  auth.uid() = user_id
);

-- 3. Policy: Allow citizens to update their own comments within 10 minutes
CREATE POLICY "Allow citizens to update their own comments within a time limit"
ON public.comments
FOR UPDATE
TO authenticated
USING (
  get_my_role() = 'citizen' AND
  auth.uid() = user_id AND
  created_at > (now() - INTERVAL '10 minutes')
)
WITH CHECK (
  -- They can only update the content, not other fields
  content IS NOT NULL
);

-- 4. Policy: Allow citizens to delete (soft delete) their own comments
CREATE POLICY "Allow citizens to soft delete their own comments"
ON public.comments
FOR UPDATE
TO authenticated
USING (
  get_my_role() = 'citizen' AND
  auth.uid() = user_id
)
WITH CHECK (
  -- This policy only allows updating the is_deleted flag
  is_deleted = true
);

-- MIGRATION FILE SEPARATOR --
-- Drop dependent objects first to ensure a clean slate
DROP TRIGGER IF EXISTS on_new_comment_created ON public.comments;
DROP FUNCTION IF EXISTS public.handle_new_reply_notification();
DROP TABLE IF EXISTS public.notifications;

-- Create notifications table
CREATE TABLE public.notifications (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL, -- The user to notify
  sender_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE, -- The user who triggered the notification
  comment_id BIGINT REFERENCES public.comments(id) ON DELETE CASCADE, -- The new comment/reply
  problem_id UUID, -- Link to the problem for context
  type TEXT NOT NULL,
  is_read BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL
);

-- Enable RLS for notifications
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

-- RLS: Users can only see and manage their own notifications
DROP POLICY IF EXISTS "Users can view and manage their own notifications" ON public.notifications;
CREATE POLICY "Users can view and manage their own notifications"
ON public.notifications
FOR ALL
TO authenticated
USING (auth.uid() = user_id);

-- Function to create a notification when a reply is posted
CREATE OR REPLACE FUNCTION public.handle_new_reply_notification()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  parent_comment_author_id UUID;
  parent_comment_problem_id UUID;
  parent_comment_solution_id UUID;
  problem_context_id UUID;
BEGIN
  -- Only trigger for replies (i.e., when parent_id is not null)
  IF NEW.parent_id IS NOT NULL THEN
    -- Find the author and context of the parent comment
    SELECT
      user_id,
      problem_id,
      solution_id
    INTO
      parent_comment_author_id,
      parent_comment_problem_id,
      parent_comment_solution_id
    FROM public.comments
    WHERE id = NEW.parent_id;

    -- Ensure we don't notify a user if they reply to their own comment
    IF parent_comment_author_id IS NOT NULL AND parent_comment_author_id != NEW.user_id THEN
      -- Determine the problem_id for context
      IF parent_comment_problem_id IS NOT NULL THEN
        problem_context_id := parent_comment_problem_id;
      ELSE
        SELECT problem_id INTO problem_context_id FROM public.solutions WHERE id = parent_comment_solution_id;
      END IF;

      -- Insert the notification
      INSERT INTO public.notifications (user_id, sender_id, comment_id, problem_id, type)
      VALUES (
        parent_comment_author_id,
        NEW.user_id,
        NEW.id,
        problem_context_id,
        'new_reply'
      );
    END IF;
  END IF;
  RETURN NEW;
END;
$$;

-- Trigger to call the function after a new comment is inserted
DROP TRIGGER IF EXISTS on_new_comment_created ON public.comments;
CREATE TRIGGER on_new_comment_created
  AFTER INSERT ON public.comments
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_reply_notification();

-- MIGRATION FILE SEPARATOR --
-- Add city, region, and pincode columns to the problems table if they don't exist
ALTER TABLE public.problems
ADD COLUMN IF NOT EXISTS city TEXT,
ADD COLUMN IF NOT EXISTS region TEXT;

-- First, ensure the helper function is up-to-date.
-- ...existing code...
CREATE OR REPLACE FUNCTION get_my_role()
RETURNS TEXT AS $$
BEGIN
  RETURN (
    SELECT COALESCE(
      (SELECT role FROM public.profiles WHERE id = auth.uid()),
      'anon'
    )
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permission to the function
GRANT EXECUTE ON FUNCTION get_my_role() TO authenticated, anon;


-- We will modify the existing update policy to be more permissive for owners.
-- It's better to have one clear UPDATE policy than multiple ones that can conflict.

-- Let's drop any potentially conflicting or old update policies first to ensure a clean slate.
-- Note: Replace "Your existing update policy name" with the actual name if you have one.
-- For this example, I'll assume a common naming convention.
DROP POLICY IF EXISTS "Allow users to update their own problems" ON public.problems;
DROP POLICY IF EXISTS "Allow users to update their own problem details" ON public.problems;


-- Create a single, comprehensive UPDATE policy.
CREATE POLICY "Allow users to update their own problems"
ON public.problems
FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (
    auth.uid() = user_id AND
    (get_my_role() = 'admin' OR get_my_role() = 'citizen')
);

-- Note on column-level security:
-- The policy above grants permission to update the *row*. The application layer
-- should be responsible for controlling *which columns* a non-admin user can edit
-- (e.g., title, description, city, region, pincode, but not status or upvote count).
-- RLS in PostgreSQL does not have a simple `WITH CHECK` syntax for specific columns.
-- The application should only send the fields that are permissible for the user to change.


-- MIGRATION FILE SEPARATOR --
-- Enable the PostGIS extension if it's not already enabled.
CREATE EXTENSION IF NOT EXISTS postgis WITH SCHEMA extensions;

-- 1. Add the new 'location' column with the geography type.
-- It's nullable initially to allow for a two-step data migration.
ALTER TABLE public.problems
ADD COLUMN IF NOT EXISTS location geography(Point, 4326);

-- 2. Populate the new 'location' column from the existing latitude and longitude columns.
-- This statement runs only if the location column is present and empty for some rows.
UPDATE public.problems
SET location = ST_SetSRID(ST_MakePoint(longitude, latitude), 4326)
WHERE location IS NULL AND latitude IS NOT NULL AND longitude IS NOT NULL;

-- 3. (Optional but recommended) Drop the old latitude and longitude columns
-- You can uncomment these lines if you have verified the data migration is successful.
-- ALTER TABLE public.problems DROP COLUMN IF EXISTS latitude;
-- ALTER TABLE public.problems DROP COLUMN IF EXISTS longitude;

-- 4. Create the spatial index on the new 'location' column.
-- This was the step that failed in the previous migration.
CREATE INDEX IF NOT EXISTS problems_location_idx ON public.problems USING GIST (location);


-- MIGRATION FILE SEPARATOR --
-- 1. Create the Materialized View to store correlation results.
-- This view will hold the pre-computed correlation scores between problem categories within specific regions.
CREATE MATERIALIZED VIEW IF NOT EXISTS public.problem_correlations AS
SELECT
    NULL::text AS region_id,
    NULL::problem_category AS category_a,
    NULL::problem_category AS category_b,
    NULL::bigint AS count_a,
    NULL::bigint AS count_b,
    NULL::bigint AS co_occurrence,
    NULL::float AS correlation_score,
    NULL::timestamptz AS last_updated_at
WITH NO DATA;

-- Create an index for faster querying by region and score
CREATE UNIQUE INDEX IF NOT EXISTS idx_problem_correlations_unique ON public.problem_correlations(region_id, category_a, category_b);
CREATE INDEX IF NOT EXISTS idx_problem_correlations_score ON public.problem_correlations(correlation_score);


-- 2. Create the function to calculate and refresh the materialized view.
CREATE OR REPLACE FUNCTION public.calculate_problem_correlations()
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
    grid_size float := 0.05; -- Approx. 5.5 km at the equator
BEGIN
    -- Step 1: Create a temporary table to hold problems snapped to a grid
    CREATE TEMP TABLE problems_in_grid AS
    SELECT
        p.id,
        p.category,
        ST_SnapToGrid(p.location, grid_size) as grid_cell
    FROM
        public.problems p
    WHERE
        p.location IS NOT NULL;

    -- Step 2: Create a temporary table for category counts within each grid cell
    CREATE TEMP TABLE category_counts_in_grid AS
    SELECT
        grid_cell,
        category,
        COUNT(id) as problem_count
    FROM
        problems_in_grid
    GROUP BY
        grid_cell,
        category;

    -- Step 3: Refresh the materialized view with the new correlation data
    TRUNCATE TABLE public.problem_correlations;

    INSERT INTO public.problem_correlations (
        region_id,
        category_a,
        category_b,
        count_a,
        count_b,
        co_occurrence,
        correlation_score,
        last_updated_at
    )
    WITH pairwise_counts AS (
        -- Create pairs of problems that co-occur in the same grid cell
        SELECT
            a.grid_cell,
            a.category AS category_a,
            b.category AS category_b
        FROM
            problems_in_grid a
        JOIN
            problems_in_grid b ON a.grid_cell = b.grid_cell AND a.category < b.category -- self-join to create pairs, ensuring a < b to avoid duplicates
    ),
    co_occurrence_counts AS (
        -- Count how many times each pair of categories appears together
        SELECT
            grid_cell,
            category_a,
            category_b,
            COUNT(*) as intersection_count
        FROM
            pairwise_counts
        GROUP BY
            grid_cell,
            category_a,
            category_b
    )
    -- Final calculation and insertion
    SELECT
        ST_AsText(coc.grid_cell) AS region_id,
        coc.category_a,
        coc.category_b,
        cat_a.problem_count AS count_a,
        cat_b.problem_count AS count_b,
        coc.intersection_count AS co_occurrence,
        -- Correlation Score Formula: intersection / sqrt(total_A * total_B)
        coc.intersection_count / sqrt(cat_a.problem_count * cat_b.problem_count) AS correlation_score,
        now() AS last_updated_at
    FROM
        co_occurrence_counts coc
    JOIN
        category_counts_in_grid cat_a ON coc.grid_cell = cat_a.grid_cell AND coc.category_a = cat_a.category
    JOIN
        category_counts_in_grid cat_b ON coc.grid_cell = cat_b.grid_cell AND coc.category_b = cat_b.category
    WHERE
        -- Ensure there's a valid calculation to be made
        cat_a.problem_count > 0 AND cat_b.problem_count > 0;

    -- Clean up temporary tables
    DROP TABLE problems_in_grid;
    DROP TABLE category_counts_in_grid;
END;
$$;

-- 3. Set up RLS for the new materialized view
-- ...existing code...

-- Allow anyone (citizens, ministries) to read the correlation data.
-- The data is aggregated and does not contain sensitive user information.
DROP POLICY IF EXISTS "Allow public read access to problem correlations" ON public.problem_correlations;
-- ...existing code...

-- Grant usage to the function
GRANT EXECUTE ON FUNCTION public.calculate_problem_correlations() TO postgres, service_role;


-- MIGRATION FILE SEPARATOR --
-- This function finds problem correlations within a specified radius from a given point.
CREATE OR REPLACE FUNCTION public.get_nearby_correlations(
    lat double precision,
    long double precision,
    radius_meters double precision
)
RETURNS TABLE (
    region_id text,
    category_a problem_category,
    category_b problem_category,
    correlation_score double precision,
    co_occurrence bigint,
    center_point_wkt text
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT
        pc.region_id,
        pc.category_a,
        pc.category_b,
        pc.correlation_score,
        pc.co_occurrence,
        ST_AsText(ST_Centroid(ST_GeomFromText(pc.region_id))) as center_point_wkt
    FROM
        public.problem_correlations pc
    WHERE
        -- Check if the correlation's region (grid cell) is within the specified radius
        ST_DWithin(
            ST_GeomFromText(pc.region_id),
            ST_SetSRID(ST_MakePoint(long, lat), 4326)::geography,
            radius_meters
        )
    ORDER BY
        pc.correlation_score DESC;
END;
$$;

-- Grant execute permission to the function
GRANT EXECUTE ON FUNCTION public.get_nearby_correlations(double precision, double precision, double precision) TO authenticated, anon;


-- MIGRATION FILE SEPARATOR --
-- This migration schedules the `problem_correlations` materialized view to be refreshed daily.
-- This avoids the performance overhead of refreshing the view on every single API call.

-- 1. Enable pg_cron if it's not already enabled.
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- 2. Grant usage to the cron schema to the postgres role
-- This is necessary to allow the postgres user to schedule jobs.
GRANT USAGE ON SCHEMA cron TO postgres;

-- 3. Schedule the refresh function to run once every day at midnight.
-- The `cron.schedule` function takes two arguments:
-- The first is the cron schedule string. '0 0 * * *' means at minute 0 of hour 0 every day.
-- The second is the SQL command to execute.
-- We use a DO block to call our existing function.
SELECT cron.schedule(
  'refresh-correlations-daily',
  '0 0 * * *',
  $$
  BEGIN
    PERFORM public.calculate_problem_correlations();
  END;
  $$
);


-- MIGRATION FILE SEPARATOR --
-- This migration enhances the correlation engine by adding powerful filtering capabilities
-- for the Ministry Dashboard. It rebuilds the materialized view to include date information
-- and creates a new function to query based on various criteria.

-- Step 1: Drop the old function and view to rebuild them.
-- It's safe to drop them as the view is designed to be rebuilt from scratch.
DROP FUNCTION IF EXISTS public.get_nearby_correlations(double precision, double precision, double precision);
DROP FUNCTION IF EXISTS public.calculate_problem_correlations();
-- ...existing code...

-- Step 2: Re-create the Materialized View with a new 'latest_problem_date' column.
-- ...existing code...

-- Create indexes for faster querying
CREATE UNIQUE INDEX IF NOT EXISTS idx_problem_correlations_unique ON public.problem_correlations(region_id, category_a, category_b);
CREATE INDEX IF NOT EXISTS idx_problem_correlations_score ON public.problem_correlations(correlation_score);
CREATE INDEX IF NOT EXISTS idx_problem_correlations_date ON public.problem_correlations(latest_problem_date);
CREATE INDEX IF NOT EXISTS idx_problem_correlations_city ON public.problem_correlations(city);


-- Step 3: Re-create the calculation function to populate the new columns.
CREATE OR REPLACE FUNCTION public.calculate_problem_correlations()
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
    grid_size float := 0.05; -- Approx. 5.5 km
BEGIN
    CREATE TEMP TABLE problems_in_grid AS
    SELECT
        p.id,
        p.category,
        p.city,
        p.region,
        p.created_at,
        ST_SnapToGrid(p.location, grid_size) as grid_cell
    FROM public.problems p
    WHERE p.location IS NOT NULL;

    CREATE TEMP TABLE category_counts_in_grid AS
    SELECT grid_cell, category, COUNT(id) as problem_count
    FROM problems_in_grid
    GROUP BY grid_cell, category;

    TRUNCATE TABLE public.problem_correlations;

    INSERT INTO public.problem_correlations (
        region_id, city, region, category_a, category_b, count_a, count_b,
        co_occurrence, correlation_score, latest_problem_date, last_updated_at
    )
    WITH pairwise_counts AS (
        SELECT
            a.grid_cell,
            a.category AS category_a,
            b.category AS category_b,
            GREATEST(a.created_at, b.created_at) as latest_date,
            -- Use the city/region from one of the pairs (assuming they are in the same grid)
            MAX(a.city) as city,
            MAX(a.region) as region
        FROM problems_in_grid a
        JOIN problems_in_grid b ON a.grid_cell = b.grid_cell AND a.category < b.category
        GROUP BY a.grid_cell, a.category, b.category, GREATEST(a.created_at, b.created_at)
    ),
    co_occurrence_counts AS (
        SELECT
            grid_cell, category_a, category_b, city, region,
            COUNT(*) as intersection_count,
            MAX(latest_date) as max_problem_date
        FROM pairwise_counts
        GROUP BY grid_cell, category_a, category_b, city, region
    )
    SELECT
        ST_AsText(coc.grid_cell) AS region_id,
        coc.city,
        coc.region,
        coc.category_a,
        coc.category_b,
        cat_a.problem_count AS count_a,
        cat_b.problem_count AS count_b,
        coc.intersection_count AS co_occurrence,
        coc.intersection_count / sqrt(cat_a.problem_count * cat_b.problem_count) AS correlation_score,
        coc.max_problem_date,
        now() AS last_updated_at
    FROM co_occurrence_counts coc
    JOIN category_counts_in_grid cat_a ON coc.grid_cell = cat_a.grid_cell AND coc.category_a = cat_a.category
    JOIN category_counts_in_grid cat_b ON coc.grid_cell = cat_b.grid_cell AND coc.category_b = cat_b.category
    WHERE cat_a.problem_count > 0 AND cat_b.problem_count > 0;

    DROP TABLE problems_in_grid;
    DROP TABLE category_counts_in_grid;
END;
$$;

-- Step 4: Re-create the nearby correlations function (no logic change, just for dependency)
CREATE OR REPLACE FUNCTION public.get_nearby_correlations(
    lat double precision,
    long double precision,
    radius_meters double precision
)
RETURNS TABLE (
    region_id text, category_a problem_category, category_b problem_category,
    correlation_score double precision, co_occurrence bigint, center_point_wkt text
)
LANGUAGE plpgsql AS $$
BEGIN
    RETURN QUERY
    SELECT pc.region_id, pc.category_a, pc.category_b, pc.correlation_score, pc.co_occurrence,
           ST_AsText(ST_Centroid(ST_GeomFromText(pc.region_id))) as center_point_wkt
    FROM public.problem_correlations pc
    WHERE ST_DWithin(
        ST_GeomFromText(pc.region_id),
        ST_SetSRID(ST_MakePoint(long, lat), 4326)::geography,
        radius_meters
    )
    ORDER BY pc.correlation_score DESC;
END;
$$;


-- Step 5: Create the NEW advanced filtering function for the Ministry dashboard
CREATE OR REPLACE FUNCTION public.get_filtered_correlations(
    start_date timestamptz DEFAULT NULL,
    end_date timestamptz DEFAULT NULL,
    cat_filter problem_category[] DEFAULT NULL,
    city_filter text DEFAULT NULL
)
RETURNS SETOF public.problem_correlations
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT *
    FROM public.problem_correlations pc
    WHERE
        (start_date IS NULL OR pc.latest_problem_date >= start_date) AND
        (end_date IS NULL OR pc.latest_problem_date <= end_date) AND
        (cat_filter IS NULL OR pc.category_a = ANY(cat_filter) OR pc.category_b = ANY(cat_filter)) AND
        (city_filter IS NULL OR pc.city ILIKE city_filter);
END;
$$;

-- Step 6: Grant permissions for the new and updated functions
GRANT EXECUTE ON FUNCTION public.calculate_problem_correlations() TO postgres, service_role;
GRANT EXECUTE ON FUNCTION public.get_nearby_correlations(double precision, double precision, double precision) TO authenticated, anon;
GRANT EXECUTE ON FUNCTION public.get_filtered_correlations(timestamptz, timestamptz, problem_category[], text) TO authenticated;

-- MIGRATION FILE SEPARATOR --
-- Aggregated vote totals per problem to keep UI in sync without heavy joins
CREATE OR REPLACE VIEW public.problem_vote_totals AS
SELECT
  votable_id AS problem_id,
  COALESCE(SUM(CASE vote_type WHEN 'upvote' THEN 1 WHEN 'downvote' THEN -1 ELSE 0 END), 0) AS net_votes,
  COUNT(*) FILTER (WHERE vote_type = 'upvote') AS upvotes,
  COUNT(*) FILTER (WHERE vote_type = 'downvote') AS downvotes,
  COUNT(*) AS total_votes,
  MAX(created_at) AS last_activity_at
FROM public.votes
WHERE votable_type = 'problem'
GROUP BY votable_id;

COMMENT ON VIEW public.problem_vote_totals IS 'Aggregated vote counters for each problem (net/up/down)';
